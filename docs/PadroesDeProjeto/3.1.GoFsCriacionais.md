# 3.1. Módulo Padrões de Projeto GoFs Criacionais

## Factory

O padrão factory permite encapsular e padronizar a interface da criação objetos.
Com isso, é possível ter vários objetos diferentes, mas com mesma interface,
sendo criado de forma desacoplada. Além disso, como a criação do objeto foi
encapsulada, alterações nas dependências desses objetos não afetará toda a aplicação, mas somente a fábrica desse objeto.

No nosso projeto, criamos fábricas para todos os objetos que podem ser no futuro
substituídos por outros ou objetos que irão receber como parâmetro suas 
dependências. Dessa forma, a criação fica encapsulada e desacoplada, facilitando
refatorações futuras.

<!-- tabs:start -->

#### **Factories para os Adapters**
<figure align="center">

  ![brainstorm](../assets/gofsCriacionais/AdaptersFactories.png)
  <figcaption>Factories dos Adapters - Visão Geral</figcaption>
</figure>

<!-- tabs:start -->
#### **Factory Para o HashAdapter**
```typescript
export interface IHash {
  ... (Implementação pode ser vista na documentação dos Adapters)
}

export class BcryptHashAdapter implements IHash {
  ... (Implementação pode ser vista na documentação dos Adapters)
}

export class BcryptHashFactory implements IHashFactory {
  createHash(): IHash {
    return new BcryptHashAdapter();
  }
}
```

#### **Factory Para o AuthAdapter**
```typescript
export interface IAuth {
  ... (Implementação pode ser vista na documentação dos Adapters)
}

export class JwtAuthAdapter implements IAuth {
  ... (Implementação pode ser vista na documentação dos Adapters)
}

export class AuthFactory implements IAuthFactory {
  createAuth(): IAuth {
    return new JwtAuthAdapter();
  }
}

```

<!-- tabs:end -->


#### **Factories para os Commands**
<figure align="center">

  ![brainstorm](../assets/gofsCriacionais/CommandsFactories.png)
  <figcaption>Factories para os Commands</figcaption>
</figure>

<!-- Command Factories Checkpoint -->

<!-- tabs:start -->

#### **LikeArtistUseCase.ts**
```typescript
interface ICreateLikeArtistDTO {
  user_id: string;
  artist_id: string;
}

export class LikeArtistUseCase implements ICommand<ICreateLikeArtistDTO, void> {
  constructor(private artistRepository: IArtistRepository) {}

  async execute({ user_id, artist_id }: ICreateLikeArtistDTO): Promise<void> {
    ...
  }
}
```

#### **SearchArtistUseCase.ts**
```typescript
interface ISearchArtistDTO {
  name: string;
}

export class SearchArtistUseCase
  implements ICommand<ISearchArtistDTO, Artist[]>
{
  constructor(private artistRepository: IArtistRepository) {}

  async execute({ name }: ISearchArtistDTO): Promise<Artist[]> {
    ...
  }
}
```

#### **SearchByIdUseCase.ts**
```typescript
interface IRequest {
  artist_id: string;
}

interface IResponse {
  artist: Artist | null;
}

export class SearchByIdUseCase implements ICommand<IRequest, IResponse> {
  constructor(private artistRepository: IArtistRepository) {}

  async execute({ artist_id }: IRequest): Promise<IResponse> {
    ...
  }
}
```

#### **UnilikeArtistUseCase.ts**
```typescript
interface ICreateLikeArtistDTO {
  user_id: string;
  artist_id: string;
}

export class UnlikeArtistUseCase
  implements ICommand<ICreateLikeArtistDTO, void>
{
  constructor(private artistRepository: IArtistRepository) {}

  async execute({ user_id, artist_id }: ICreateLikeArtistDTO): Promise<void> {
    ...
  }
}
```

#### **CreateMusicUseCase.ts**
```typescript
interface IRequest {
  albumId: string;
  title: string;
  youtubeUrl: string;
  iconUrl: string;
  verses: {
    text: string;
    startTime: number;
    endTime: number;
    translatedText?: string;
  }[];
}

type IResponse = Music;

export class CreateMusicUseCase implements ICommand<IRequest, IResponse> {
  constructor(private musicRepository: IMusicRepository) {}

  public async execute({
    albumId,
    iconUrl,
    title,
    youtubeUrl,
    verses,
  }: IRequest): Promise<Music> {
    ...
  }
}
```

#### **GetMusicUseCase.ts**
```typescript
interface IRequest {
  id: string;
}

type IResponse = Music & { verses: Verse[]; likes: number };

export class GetMusicUseCase implements ICommand<IRequest, IResponse> {
  constructor(private musicRepository: IMusicRepository) {}

  public async execute({ id }: IRequest): Promise<IResponse> {
    ...
  }
}
```

#### **LikeMusicUseCase.ts**
```typescript
interface ICreateLIkeMusicDTO {
  user_id: string;
  music_id: string;
}

export class LikeMusicUseCase implements ICommand<ICreateLIkeMusicDTO, void> {
  constructor(private musicRepository: IMusicRepository) {}

  async execute({ user_id, music_id }: ICreateLIkeMusicDTO): Promise<void> {
    ...
  }
}
```

#### **ListTopMusicsUseCase.ts**
```typescript
interface IRequest {
  number: number;
  dataInit: Date;
  dataFinished: Date;
}

type IResponse = Music[];

export class ListTopMusicsUseCase implements ICommand<IRequest, IResponse> {
  constructor(private musicRepository: IMusicRepository) {}

  public async execute({
    number,
    dataInit,
    dataFinished,
  }: IRequest): Promise<IResponse> {
    ...
  }
}
```

#### **SearchByArtistMusicUseCase.ts**
```typescript
interface IRequest {
  artistId: string;
}

type IResponse = Music[];

export class SearchByArtistMusicUseCase
  implements ICommand<IRequest, IResponse>
{
  constructor(private musicRepository: IMusicRepository) {}

  public async execute({ artistId }: IRequest): Promise<Music[]> {
    ...
  }
}
```

#### **SearchMusicUseCase.ts**
```typescript
interface ISearchMusicDTO {
  title: string;
}

export class SearchMusicUseCase implements ICommand<ISearchMusicDTO, Music[]> {
  constructor(private musicRepository: IMusicRepository) {}

  async execute({ title }: ISearchMusicDTO): Promise<Music[]> {
    ...
  }
}
```

#### **AddMusicUseCase.ts**
```typescript
interface IRequest {
  playlist_id: string;
  music_id: string;
  user_id: string;
}

type IResponse = (Playlist & { musics: Music[] }) | null;

export class AddMusicUseCase implements ICommand<IRequest, IResponse> {
  constructor(private playlistRepository: IPlaylistRepository) {}

  async execute({
    playlist_id,
    music_id,
    user_id,
  }: IRequest): Promise<(Playlist & { musics: Music[] }) | null> {
    ...
  }
}
```

#### **CreatePlaylistUseCase.ts**
```typescript
interface ICreatePlaylistDTO {
  title: string;
  user_id: string;
}

export class CreatePlaylistUseCase
  implements ICommand<ICreatePlaylistDTO, Playlist>
{
  constructor(private playlistRepository: IPlaylistRepository) {}

  async execute({ title, user_id }: ICreatePlaylistDTO): Promise<Playlist> {
    ...
  }
}
```

#### **DeletePlaylistUseCase.ts**
```typescript
interface IRequest {
  id: string;
  userId: string;
}

export class DeletePlaylistUseCase implements ICommand<IRequest, void> {
  constructor(private playlistRepository: IPlaylistRepository) {}

  async execute({ id, userId }: IRequest): Promise<void> {
    ...
  }
}
```

#### **GetPlaylistUseCase.ts**
```typescript
interface IRequest {
  id: string;
}

type IResponse = (Playlist & { musics: Music[] }) | null;

export class GetPlaylistUseCase implements ICommand<IRequest, IResponse> {
  constructor(private playlistRepository: IPlaylistRepository) {}

  async execute({
    id,
  }: IRequest): Promise<(Playlist & { musics: Music[] }) | null> {
    ...
  }
}
```

#### **LikePlaylistUseCase.ts**
```typescript
interface ILikePlaylistDTO {
  playlistId: string;
  user_id: string;
}

export class LikePlaylistUseCase implements ICommand<ILikePlaylistDTO, void> {
  constructor(
    private playlistRepository: IPlaylistRepository,
    private userRepository: IUserRepository,
  ) {}

  async execute({ playlistId, user_id }: ILikePlaylistDTO): Promise<void> {
    ...
  }
}
```

#### **SearchPlaylistUseCase.ts**
```typescript
interface ISearchPlaylistDTO {
  title: string;
}

export class SearchPlaylistUseCase
  implements ICommand<ISearchPlaylistDTO, Playlist[]>
{
  constructor(private playlistRepository: IPlaylistRepository) {}

  async execute({ title }: ISearchPlaylistDTO): Promise<Playlist[]> {
    ...
  }
}
```

#### **AuthenticateUserUseCase.ts**
```typescript
interface IRequest {
  email: string;
  password: string;
}

type IResponse = {
  user: User;
  auth: string;
};

export class AuthenticateUserUseCase implements ICommand<IRequest, IResponse> {
  constructor(
    private userRepository: IUserRepository,
    private hash: IHash,
    private auth: IAuth,
  ) {}

  public async execute({ email, password }: IRequest): Promise<IResponse> {
    ...
  }
}
```

#### **CreateUserUseCase.ts**
```typescript
interface IRequest {
  name: string;
  email: string;
  password: string;
}

type IResponse = User;

export class CreateUserUseCase implements ICommand<IRequest, IResponse> {
  constructor(
    private userRepository: IUserRepository,
    private hash: IHash,
  ) {}

  public async execute({
    name,
    email,
    password,
  }: IRequest): Promise<IResponse> {
    ...
  }
}
```

#### **DeleteUserUseCase.ts**
```typescript
interface IRequest {
  id: string;
}

type IResponse = undefined;

export class DeleteUserUseCase implements ICommand<IRequest, IResponse> {
  constructor(private userRepository: IUserRepository) {}

  public async execute({ id }: IRequest): Promise<IResponse> {
    ...
  }
}
```

#### **GetUserUseCase.ts**
```typescript
interface IRequest {
  id: string;
}

type IResponse = User;

export class GetUserUseCase implements ICommand<IRequest, IResponse> {
  constructor(private userRepository: IUserRepository) {}

  public async execute({ id }: IRequest): Promise<IResponse> {
    ...
  }
}
```

#### **UpdateUserIconUseCase.ts**
```typescript
interface IRequest {
  user_id: string;
  filepath: string;
}

type IResponse = User;

export class UpdateUserIconUseCase implements ICommand<IRequest, IResponse> {
  constructor(private userRepository: IUserRepository) {}

  public async execute({ filepath, user_id }: IRequest): Promise<IResponse> {
    ...
  }
}
```

#### **UpdateUserUseCase.ts**
```typescript
interface IRequest {
  id: string;
  name: string | undefined;
  email: string | undefined;
  censoredMusics: boolean | undefined;
}

type IResponse = User;

export class UpdateUserUseCase implements ICommand<IRequest, IResponse> {
  constructor(private userRepository: IUserRepository) {}

  public async execute({
    id,
    name,
    email,
    censoredMusics,
  }: IRequest): Promise<IResponse> {
    ...
  }
}
```

<!-- tabs:end -->
<!-- Command Factories Checkpoint -->

Claro que essas abas não foram geradas manualmente.
Para garantir que siga exatamente o código, foi utilizado esse script:

[GenerateDocsCommandsHeaders.js](../scripts/GenerateDocsCommandsHeaders.js ':include')


#### **Factories para os Facades**
<figure align="center">

  ![brainstorm](../assets/gofsCriacionais/FacadesFactories.png) 
  <figcaption>Factories para os Facades</figcaption>
</figure>
<!-- tabs:end -->

## Singleton

O padrão singleton serve para criar instâncias únicas de um objeto, ele é
utilizado quando é necessário a reutilização e a proibição de criar múltiplos
objetos.

No nosso caso, a conexão com o banco de dados será crucial não ser duplicada.
Múltiplas conexões a um banco de dados causa lentidão ao servidor.

No futuro esse Singleton pode virar um Multiton ou Pool para ter múltiplas conexões de forma controlada.

<figure align="center">

  ![brainstorm](../assets/gofsCriacionais/Singleton.png) 
  <figcaption>Singleton</figcaption>
</figure>

<!-- tabs:start -->
#### **Singleton Para DatabaseConnection**
```typescript
import { PrismaClient } from "@prisma/client";

export class DatabaseConnection {
  private static INSTANCE: PrismaClient | null;
  private constructor() {}

  public static getInstance(): PrismaClient {
    if (!DatabaseConnection.INSTANCE) {
      DatabaseConnection.INSTANCE = new PrismaClient();
    }

    return DatabaseConnection.INSTANCE;
  }
}
```

# Referências
- [Serrano, Milene](https://arquivos.unb.br/arquivos/20242520620d033079810403788c8e690/Arquitetura_e_Desenho_de_Software_-_Aula_GoFs_Criacionais_-_Profa._Milene.pdf)
- [Refactoring Guru](https://refactoring.guru/pt-br/design-patterns/creational-patterns)
- [Fireship](https://youtu.be/tv-_1er1mWI?si=9QQtWoqDZMSPgbMH)
- [Geekific, Singleton](https://www.youtube.com/watch?v=tSZn4wkBIu8&list=PLlsmxlJgn1HJpa28yHzkBmUY-Ty71ZUGc&index=2)
- [Geekific, Factory](https://www.youtube.com/watch?v=EdFq_JIThqM&list=PLlsmxlJgn1HJpa28yHzkBmUY-Ty71ZUGc&index=3)

# Histórico de versão

| Descrição                                             | Autor                                              | Data       |
| ----------------------------------------------------- | -------------------------------------------------- | ---------- |
| Adicionando histórico de versão                       | Cauã                                               | 22/07/2024 |
| Adicionando Factories para Commands                   | Maria Luisa, Gustavo Henrique, Leonardo e Vinicius | 24/07/2024 |
| Adicionando Factories para Adapters                   | Cauã, Ian, Gustavo Kenzo e Samuel                  | 24/07/2024 |
| Adicionando Singleton                                 | Julio                                              | 24/07/2024 |
| Adicionando Factories para Facades                    | Rafael, Bruno, Lucas e Manoel                      | 25/07/2024 |
| Adicionando referências                               | Cauã                                               | 25/07/2024 |
| Adicionando explicações                               | Cauã                                               | 25/07/2024 |
| Adicionando Implementação dos Factories para Adapters | Cauã e Gustavo Kenzo                               | 10/08/2024 |
| Adicionando Implementação do Singleton                | Cauã e Gustavo Kenzo                               | 12/08/2024 |
| Adicionando Implementação das Factories para Commands | Cauã, Gustavo Kenzo e Gustavo Henrique             | 15/08/2024 |

