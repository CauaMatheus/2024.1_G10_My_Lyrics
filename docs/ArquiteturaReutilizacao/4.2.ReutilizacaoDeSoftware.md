# 4.2. Módulo Reutilização de Software

## 4.2.1 Backend:


### 4.2.1.1 Continuous Deployment (CD)

Continuous Deployment (CD) é uma prática no desenvolvimento de software onde as mudanças no código são automaticamente implantadas em um ambiente de produção ou de teste assim que passam pelos testes automatizados. Essa abordagem permite que novas funcionalidades, correções de bugs ou melhorias sejam disponibilizadas para os usuários de forma rápida e consistente.

## Como o CD Pode Ser Utilizado em Outras Aplicações

O CD pode ser utilizado em diversas aplicações para automatizar o processo de entrega de software. Com isso, torna-se possível a reutilização do código de CD que não só acelera a implantação, como também facilita a manutenção e atualização dos processos de deploy em diferentes contextos, promovendo a padronização e a confiabilidade. Exemplos de aplicações que podem utilizar o CD incluem:

1. **Aplicações Web:** O CD pode garantir que novas versões de uma aplicação web sejam automaticamente implantadas em servidores de produção assim que o código é mesclado na branch principal.
2. **Microservices:** Em arquiteturas de microsserviços, o CD pode ser configurado para implantar automaticamente cada serviço individualmente, permitindo uma entrega mais ágil e independente.
3. **Aplicações Mobile:** Para aplicações mobile, o CD pode automatizar a compilação, testes e disponibilização da nova versão do app em lojas de aplicativos (App Store, Google Play).

Além disso o CD reduz o tempo entre o desenvolvimento e a disponibilização de novas funcionalidades, aumenta a frequência de lançamentos e melhora a qualidade do software, permitindo feedback mais rápido dos usuários.

## Exemplo de CD na Aplicação

Abaixo está nosso exemplo de configuração de CD do projeto MyLyrics, que utiliza o GitHub Actions para realizar o deploy do nosso backend para uma instância EC2:

```yaml
name: backend-deployment

on:
  push:
    branches:
      - main
    paths:
      - 'backend/src/**'
      - 'backend/prisma/**'

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment: development
    steps:
      - name: Checkout the code
        uses: actions/checkout@v1

      - name: Deploy to EC2 instance
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST_TEST }}
          username: ${{ secrets.SERVER_USERNAME_TEST }}
          key: ${{ secrets.SERVER_SSH_KEY_TEST }}
          source: "./backend/"
          target: "~/.config/"

      - name: Install dependencies in EC2 instance
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST_TEST }}
          username: ${{ secrets.SERVER_USERNAME_TEST }}
          key: ${{ secrets.SERVER_SSH_KEY_TEST }}
          script: |
            cd ~/.config/backend && \
            pnpm install && \
            pnpm prisma generate && \
            pnpm prisma migrate deploy

      - name: Restart application in EC2 instance
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST_TEST }}
          username: ${{ secrets.SERVER_USERNAME_TEST }}
          key: ${{ secrets.SERVER_SSH_KEY_TEST }}
          script: cd ~/.config/backend && pm2 restart backend 
```


### 4.2.1.2 Error Handling

[Explicação da importância das padronizações de erros na api rest e como ele pode
ser utilizado em outras aplicações]
[Exemplo dos erros padronizados da aplicação]

### 4.2.1.3 Env Config

[Explicar a importância de ter e de parsear as configurações de ambientes e como
ele pode ser utilizado em outras aplicações]
[Exemplo do parser do nosso código]

### 4.2.1.4 Patterns

[Explicar a importância de ter padrões de projeto e como ele pode ser utilizado
em outras aplicações]
[Exemplo de padrões de projeto da aplicação]

## 4.2.2 Frontend:

### 4.2.2.1 Button

[Explicar a importância de ter Botões como componentes e como ele pode ser
utilizado em outras aplicações]
[Exemplo de Botões da aplicação]

### 4.2.2.1 Header

O componente Header é responsável por mostrar o menu de navegação da aplicação. Ele é composto pela logo da aplicação que redireciona o usuário para a página inicial da aplicação, e pelos botões de Categorias, Playlists e Músicas & Artistas. É fundamental que o Header seja "componentizado", pois ele está presente em grande parte da aplicação, e isso faz com que ele seja facilmente reutilizável.

O primeiro tipo de Header serve para quando o usuário está logado na aplicação. E, na direita do Header, é mostrado a foto de perfil do usuário, que irá redirecionar o usuário para a página de perfil do usuário.

<figure align="center">

![header](../assets/reutilizacao/header1.png)

  <figcaption>Header Logado</figcaption>
</figure>

O segundo tipo de Header serve para quando o usuário não está logado na aplicação. E, na direita do Header, é mostrado o botão de Login e Registrar, que irá redirecionar o usuário para a página de login e registro respectivamente.

<figure align="center">

![header](../assets/reutilizacao/header2.png)

  <figcaption>Header Deslogado</figcaption>
</figure>

### 4.2.2.1 MusicCard

[Explicar a importância de ter MusicCard como componente e como ele pode ser
utilizado em outras aplicações]
[Exemplo de MusicCard da aplicação]

# Histórico de versão

| Descrição                       | Autor          | Data       |
| ------------------------------- | -------------- | ---------- |
| Adicionando histórico de versão | Cauã           | 22/07/2024 |
| Adicionando descrição do header | Gustavo Kenzo  | 14/08/2024 |
| Adicionando descrição do CD     | Samuel Ricardo | 14/08/2024 |
